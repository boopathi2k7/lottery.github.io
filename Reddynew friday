[27/03, 2:56â€¯pm] Sridhar BOA: . Spring Boot Application (Full Code)

Step 1: Add Dependencies

Add the Redis dependency in pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>


---

Step 2: Configure Redis Connection

Update application.yml:

spring:
  redis:
    host: localhost  # If running in Docker on local machine
    port: 6379

If Redis is running inside Docker Compose or another network, replace localhost with the container name or IP.


---

Step 3: Create a Redis Publisher

import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

@Service
public class RedisMessagePublisher {
    
    private final StringRedisTemplate redisTemplate;

    public RedisMessagePublisher(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public void publish(String channel, String message) {
        redisTemplate.convertAndSend(channel, message);
        System.out.println("Published: " + message);
    }
}


---

Step 4: Create a Redis Subscriber

import org.springframework.data.redis.connection.Message;
import org.springframework.data.redis.connection.MessageListener;
import org.springframework.stereotype.Component;

@Component
public class RedisMessageSubscriber implements MessageListener {

    @Override
    public void onMessage(Message message, byte[] pattern) {
        System.out.println("Received: " + message.toString());
    }
}


---

Step 5: Configure Redis Listener

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.listener.PatternTopic;
import org.springframework.data.redis.listener.RedisMessageListenerContainer;
import org.springframework.data.redis.listener.adapter.MessageListenerAdapter;

@Configuration
public class RedisConfig {

    @Bean
    public RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
                                                   MessageListenerAdapter listenerAdapter) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.addMessageListener(listenerAdapter, new PatternTopic("my-channel"));
        return container;
    }

    @Bean
    public MessageListenerAdapter listenerAdapter(RedisMessageSubscriber subscriber) {
        return new MessageListenerAdapter(subscriber);
    }
}


---

Step 6: Test with a REST API

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class RedisTestController {

    private final RedisMessagePublisher publisher;

    public RedisTestController(RedisMessagePublisher publisher) {
        this.publisher = publisher;
    }

    @GetMapping("/publish")
    public String publishMessage(@RequestParam String message) {
        publisher.publish("my-channel", message);
        return "Message published!";
    }
}


---

3. Running the Application

1. Start Redis in Docker:

docker run --name redis-container -p 6379:6379 -d redis


2. Run your Spring Boot application.


3. Test message publishing:

http://localhost:8080/publish?message=HelloRedis

You should see Published: HelloRedis in the logs.

The subscriber should print Received: HelloRedis.





---

4. (Optional) Using Docker Compose

If you want to run both Redis and your Spring Boot app in containers, create a docker-compose.yml:

version: '3.8'
services:
  redis:
    image: redis
    container_name: redis-container
    ports:
      - "6379:6379"

  app:
    build: .
    container_name: spring-redis-app
    depends_on:
      - redis
    environment:
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PORT: 6379
    ports:
      - "8080:8080"

Then, run:

docker-compose up -d


---

This setup ensures that your Spring Boot application connects to Redis running in a container. Let me know if you need further modifications!
[28/03, 7:15â€¯am] Sridhar BOA: What is a Message Queue?

A Message Queue (MQ) is a system that enables asynchronous communication between different services, applications, or processes. It acts as a buffer where messages are stored until they are processed by the receiving system.

It helps in decoupling applications, making them scalable and fault-tolerant.

Common MQ systems include RabbitMQ, Apache Kafka, ActiveMQ, and Redis Message Queue.

Messages are typically stored in a queue and consumed in a FIFO (First In, First Out) manner.



---

What is Redis?

Redis (Remote Dictionary Server) is an in-memory data store that is primarily used as:

1. A key-value store (like a NoSQL database).


2. A cache for storing frequently accessed data.


3. A message broker for pub/sub (publish/subscribe) messaging.



Redis is known for its high speed, persistence support, and scalability.


---

What is Redis Caching?

Redis Caching is the use of Redis to store frequently accessed data in memory to improve application speed and performance.

Since Redis keeps data in RAM, reads and writes are much faster than querying a database.

It helps reduce database load and response time for applications.

Common use cases:

Caching API responses

Storing session data

Caching user authentication tokens




---

What is Redis Message Queue?

Redis can act as a message queue using its list and pub/sub features:

1. Using Lists (LPUSH & BRPOP) â€“ Acts as a FIFO queue

LPUSH queue message â†’ Adds a message to the queue.

BRPOP queue â†’ Retrieves and removes the first message.

This is useful for task queues, job processing, etc.



2. Using Pub/Sub (PUBLISH & SUBSCRIBE) â€“ Acts as a real-time event notification system

PUBLISH channel message â†’ Sends a message to subscribers.

SUBSCRIBE channel â†’ Listens for messages on a channel.

This is used for event-driven systems and real-time updates.




Redis message queues are simpler and lightweight compared to full-fledged MQ systems like Kafka or RabbitMQ but are useful for fast and temporary messaging.
[28/03, 7:22â€¯am] Sridhar BOA: No, Redis Message Queue (MQ) and Redis Caching are not the same, even if a caching system is used to store messages temporarily. Hereâ€™s why:

Key Differences Between Redis Caching and Redis MQ

Why Redis Caching Canâ€™t Fully Replace Redis MQ

In caching, data is stored for quick access and can be retrieved multiple times.

In message queues, messages are processed and removed after consumption, ensuring one-time delivery.

If caching is used like an MQ, it might lead to message loss if the cache expires before processing.


When to Use What?

Use Redis Caching if you need fast access to frequently used data.

Use Redis MQ if you need asynchronous communication between services.


Even though both use Redis, their architecture and functionality are different.
[28/03, 7:50â€¯am] Sridhar BOA: Do You Need to Download Redis Separately?

Yes, you must install Redis separately because the Spring Boot Redis dependency (spring-boot-starter-data-redis) does not include a Redis server.


---

Ways to Run Redis

1. Install Redis Locally (Manually)

For Windows:

Download from Memurai or Redis for Windows.

Extract and run redis-server.exe.


For Linux/macOS:

sudo apt update && sudo apt install redis -y  # Ubuntu
brew install redis  # macOS
redis-server  # Start Redis server



---

2. Run Redis in Docker (Recommended)

If you don't want to install Redis manually, you can run it in Docker:

docker run --name my-redis -p 6379:6379 -d redis

This will start a Redis container that Spring Boot can connect to.


---

3. Use an Embedded Redis Server (For Testing Only)

If you donâ€™t want to install Redis separately and just need it for local testing, you can use Embedded Redis:

Add Dependency for Embedded Redis

<dependency>
    <groupId>it.ozimov</groupId>
    <artifactId>embedded-redis</artifactId>
    <version>0.7.2</version>
</dependency>

Start Embedded Redis in Spring Boot

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import redis.embedded.RedisServer;
import java.io.IOException;

@Configuration
public class EmbeddedRedisConfig {

    private RedisServer redisServer;

    @Bean
    public RedisServer redisServer() throws IOException {
        redisServer = new RedisServer(6379); // Start Redis on port 6379
        redisServer.start();
        return redisServer;
    }
}

Note: Embedded Redis is for development/testing only and should not be used in production.


---

Will Spring Boot Work Without Installing Redis?

No, Spring Boot needs a running Redis server to work with caching or messaging. You can either:

Install Redis manually.

Use Docker.

Use Embedded Redis (for testing only).


If Redis is not running, Spring Boot will throw a connection error when trying to access Redis.
[28/03, 7:57â€¯am] Sridhar BOA: Steps to Implement Redis Message Queue (Producer & Consumer)

1. Install Redis on Your System or Use Docker

If you haven't installed Redis, run it via Docker:

docker run --name redis-mq -p 6379:6379 -d redis

Now, Redis will be running on port 6379.


---

2. Create Server 1 (Producer) - Sends Messages to Redis

Step 1: Create a Spring Boot Project

Create a Spring Boot project and add these dependencies in pom.xml:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>


---

Step 2: Configure Redis in application.properties

spring.redis.host=localhost
spring.redis.port=6379


---

Step 3: Create a Redis Message Publisher

import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

@Service
public class RedisMessagePublisher {
    private final StringRedisTemplate redisTemplate;

    public RedisMessagePublisher(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public void sendMessage(String channel, String message) {
        redisTemplate.convertAndSend(channel, message);
        System.out.println("Sent message: " + message);
    }
}


---

Step 4: Create a REST Controller to Send Messages

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MessageController {
    private final RedisMessagePublisher messagePublisher;

    public MessageController(RedisMessagePublisher messagePublisher) {
        this.messagePublisher = messagePublisher;
    }

    @GetMapping("/send")
    public String sendMessage(@RequestParam String message) {
        messagePublisher.sendMessage("my-channel", message);
        return "Message sent: " + message;
    }
}


---

3. Create Server 2 (Consumer) - Receives Messages from Redis

Step 1: Create Another Spring Boot Project

Create a separate Spring Boot project for Server 2 (Consumer) and add the same dependencies.


---

Step 2: Configure Redis in application.properties

spring.redis.host=localhost
spring.redis.port=6379


---

Step 3: Create a Redis Message Subscriber

import org.springframework.data.redis.connection.Message;
import org.springframework.data.redis.connection.MessageListener;
import org.springframework.stereotype.Service;

@Service
public class RedisMessageSubscriber implements MessageListener {

    @Override
    public void onMessage(Message message, byte[] pattern) {
        System.out.println("Received message: " + message.toString());
    }
}


---

Step 4: Configure Redis Message Listener

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.listener.PatternTopic;
import org.springframework.data.redis.listener.RedisMessageListenerContainer;
import org.springframework.data.redis.listener.adapter.MessageListenerAdapter;

@Configuration
public class RedisMQConfig {

    @Bean
    RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
                                            MessageListenerAdapter listenerAdapter) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.addMessageListener(listenerAdapter, new PatternTopic("my-channel"));
        return container;
    }

    @Bean
    MessageListenerAdapter listenerAdapter(RedisMessageSubscriber subscriber) {
        return new MessageListenerAdapter(subscriber, "onMessage");
    }
}


---

4. How to Run and Test

Step 1: Start Redis

Ensure Redis is running:

redis-server

Or, if using Docker:

docker start redis-mq


---

Step 2: Start Server 1 (Producer)

Run the Spring Boot Producer application.


---

Step 3: Start Server 2 (Consumer)

Run the Spring Boot Consumer application.


---

Step 4: Send a Message from Server 1

Open a browser or Postman and send a message using the Producer API:

http://localhost:8080/send?message=HelloRedis


---

Step 5: Verify Message is Received by Server 2

Check the logs of the Consumer (Server 2):

Received message: HelloRedis


---

Final Summary

âœ… Server 1 (Producer) sends messages to Redis.
âœ… Server 2 (Consumer) listens for messages and processes them.
âœ… Messages are passed via Redis Message Queue.

This is a simple and scalable way to implement a message queue using Redis and Spring Boot. ðŸš€
[28/03, 8:01â€¯am] Sridhar BOA: In Redis Pub/Sub, the Producer (Publisher) does not require a connectorâ€”it directly sends messages to Redis. However, the Consumer (Subscriber) needs a connector to listen for messages.


---

Understanding Redis Connections for Producer & Consumer

1. Producer (Publisher) â€“ No Connector Needed

The Producer simply publishes messages to a Redis channel using StringRedisTemplate.convertAndSend().

It does not require a persistent connection to listen for messages.


Code Example (Producer)

import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

@Service
public class RedisMessagePublisher {
    private final StringRedisTemplate redisTemplate;

    public RedisMessagePublisher(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public void sendMessage(String channel, String message) {
        redisTemplate.convertAndSend(channel, message);
        System.out.println("Sent message: " + message);
    }
}

âœ… This sends a message to Redis instantly and does not require a connection to remain open.


---

2. Consumer (Subscriber) â€“ Requires a Connector

The Consumer must continuously listen for messages on a Redis channel.

It requires a Redis connection to subscribe to a channel and receive messages.

This is achieved using RedisMessageListenerContainer.


Code Example (Consumer)

import org.springframework.data.redis.connection.Message;
import org.springframework.data.redis.connection.MessageListener;
import org.springframework.stereotype.Service;

@Service
public class RedisMessageSubscriber implements MessageListener {
    @Override
    public void onMessage(Message message, byte[] pattern) {
        System.out.println("Received message: " + message.toString());
    }
}

Connector Configuration (Consumer Only)

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.listener.PatternTopic;
import org.springframework.data.redis.listener.RedisMessageListenerContainer;
import org.springframework.data.redis.listener.adapter.MessageListenerAdapter;

@Configuration
public class RedisMQConfig {

    @Bean
    RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
                                            MessageListenerAdapter listenerAdapter) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.addMessageListener(listenerAdapter, new PatternTopic("my-channel"));
        return container;
    }

    @Bean
    MessageListenerAdapter listenerAdapter(RedisMessageSubscriber subscriber) {
        return new MessageListenerAdapter(subscriber, "onMessage");
    }
}

âœ… This keeps a persistent connection to Redis for listening to messages.


---

Final Answer: Does Producer Need a Connector?

No, the producer just sends messages using convertAndSend() and does not need a persistent connection.

Yes, the consumer needs a connector (RedisMessageListenerContainer) because it must continuously listen for new messages.
